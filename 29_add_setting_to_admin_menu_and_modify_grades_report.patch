Index: mod/quiz/report/overview/report.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This file defines the quiz overview report class.\n *\n * @package   quiz_overview\n * @copyright 1999 onwards Martin Dougiamas and others {@link http://moodle.com}\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG->dirroot . '/mod/quiz/report/attemptsreport.php');\nrequire_once($CFG->dirroot . '/mod/quiz/report/overview/overview_options.php');\nrequire_once($CFG->dirroot . '/mod/quiz/report/overview/overview_form.php');\nrequire_once($CFG->dirroot . '/mod/quiz/report/overview/overview_table.php');\n\n\n/**\n * Quiz report subclass for the overview (grades) report.\n *\n * @copyright 1999 onwards Martin Dougiamas and others {@link http://moodle.com}\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nclass quiz_overview_report extends quiz_attempts_report {\n\n    public function display($quiz, $cm, $course) {\n        global $CFG, $DB, $OUTPUT, $PAGE;\n\n        list($currentgroup, $students, $groupstudents, $allowed) =\n                $this->init('overview', 'quiz_overview_settings_form', $quiz, $cm, $course);\n        $options = new quiz_overview_options('overview', $quiz, $cm, $course);\n\n        if ($fromform = $this->form->get_data()) {\n            $options->process_settings_from_form($fromform);\n\n        } else {\n            $options->process_settings_from_params();\n        }\n\n        $this->form->set_data($options->get_initial_form_data());\n\n        if ($options->attempts == self::ALL_WITH) {\n            // This option is only available to users who can access all groups in\n            // groups mode, so setting allowed to empty (which means all quiz attempts\n            // are accessible, is not a security porblem.\n            $allowed = array();\n        }\n\n        // Load the required questions.\n        $questions = quiz_report_get_significant_questions($quiz);\n\n        // Prepare for downloading, if applicable.\n        $courseshortname = format_string($course->shortname, true,\n                array('context' => context_course::instance($course->id)));\n        $table = new quiz_overview_table($quiz, $this->context, $this->qmsubselect,\n                $options, $groupstudents, $students, $questions, $this->get_base_url());\n        $filename = quiz_report_download_filename(get_string('overviewfilename', 'quiz_overview'),\n                $courseshortname, $quiz->name);\n        $table->is_downloading($options->download, $filename,\n                $courseshortname . ' ' . format_string($quiz->name, true));\n        if ($table->is_downloading()) {\n            raise_memory_limit(MEMORY_EXTRA);\n        }\n\n        $this->process_actions($quiz, $cm, $currentgroup, $groupstudents, $allowed, $options->get_url());\n\n        // Start output.\n        if (!$table->is_downloading()) {\n            // Only print headers if not asked to download data.\n            $this->print_header_and_tabs($cm, $course, $quiz, $this->mode);\n        }\n\n        if ($groupmode = groups_get_activity_groupmode($cm)) {\n            // Groups are being used, so output the group selector if we are not downloading.\n            if (!$table->is_downloading()) {\n                groups_print_activity_menu($cm, $options->get_url());\n            }\n        }\n\n        // Print information on the number of existing attempts.\n        if (!$table->is_downloading()) {\n            // Do not print notices when downloading.\n            if ($strattemptnum = quiz_num_attempt_summary($quiz, $cm, true, $currentgroup)) {\n                echo '<div class=\"quizattemptcounts\">' . $strattemptnum . '</div>';\n            }\n        }\n\n        $hasquestions = quiz_questions_in_quiz($quiz->questions);\n        if (!$table->is_downloading()) {\n            if (!$hasquestions) {\n                echo quiz_no_questions_message($quiz, $cm, $this->context);\n            } else if (!$students) {\n                echo $OUTPUT->notification(get_string('nostudentsyet'));\n            } else if ($currentgroup && !$groupstudents) {\n                echo $OUTPUT->notification(get_string('nostudentsingroup'));\n            }\n\n            // Print the display options.\n            $this->form->display();\n        }\n\n        $hasstudents = $students && (!$currentgroup || $groupstudents);\n        if ($hasquestions && ($hasstudents || $options->attempts == self::ALL_WITH)) {\n            // Construct the SQL.\n            $fields = $DB->sql_concat('u.id', \"'#'\", 'COALESCE(quiza.attempt, 0)') .\n                    ' AS uniqueid, ';\n            if ($this->qmsubselect) {\n                $fields .=\n                    \"(CASE \" .\n                    \"   WHEN {$this->qmsubselect} THEN 1\" .\n                    \"   ELSE 0 \" .\n                    \"END) AS gradedattempt, \";\n            }\n\n            list($fields, $from, $where, $params) = $table->base_sql($allowed);\n\n            $table->set_count_sql(\"SELECT COUNT(1) FROM $from WHERE $where\", $params);\n\n            // Test to see if there are any regraded attempts to be listed.\n            $fields .= \", COALESCE((\n                                SELECT MAX(qqr.regraded)\n                                  FROM {quiz_overview_regrades} qqr\n                                 WHERE qqr.questionusageid = quiza.uniqueid\n                          ), -1) AS regraded\";\n            if ($options->onlyregraded) {\n                $where .= \" AND COALESCE((\n                                    SELECT MAX(qqr.regraded)\n                                      FROM {quiz_overview_regrades} qqr\n                                     WHERE qqr.questionusageid = quiza.uniqueid\n                                ), -1) <> -1\";\n            }\n            $table->set_sql($fields, $from, $where, $params);\n\n            if (!$table->is_downloading()) {\n                // Output the regrade buttons.\n                if (has_capability('mod/quiz:regrade', $this->context)) {\n                    $regradesneeded = $this->count_question_attempts_needing_regrade(\n                            $quiz, $groupstudents);\n                    if ($currentgroup) {\n                        $a= new stdClass();\n                        $a->groupname = groups_get_group_name($currentgroup);\n                        $a->coursestudents = get_string('participants');\n                        $a->countregradeneeded = $regradesneeded;\n                        $regradealldrydolabel =\n                                get_string('regradealldrydogroup', 'quiz_overview', $a);\n                        $regradealldrylabel =\n                                get_string('regradealldrygroup', 'quiz_overview', $a);\n                        $regradealllabel =\n                                get_string('regradeallgroup', 'quiz_overview', $a);\n                    } else {\n                        $regradealldrydolabel =\n                                get_string('regradealldrydo', 'quiz_overview', $regradesneeded);\n                        $regradealldrylabel =\n                                get_string('regradealldry', 'quiz_overview');\n                        $regradealllabel =\n                                get_string('regradeall', 'quiz_overview');\n                    }\n                    $displayurl = new moodle_url($options->get_url(), array('sesskey' => sesskey()));\n                    echo '<div class=\"mdl-align\">';\n                    echo '<form action=\"'.$displayurl->out_omit_querystring().'\">';\n                    echo '<div>';\n                    echo html_writer::input_hidden_params($displayurl);\n                    echo '<input type=\"submit\" name=\"regradeall\" value=\"'.$regradealllabel.'\"/>';\n                    echo '<input type=\"submit\" name=\"regradealldry\" value=\"' .\n                            $regradealldrylabel . '\"/>';\n                    if ($regradesneeded) {\n                        echo '<input type=\"submit\" name=\"regradealldrydo\" value=\"' .\n                                $regradealldrydolabel . '\"/>';\n                    }\n                    echo '</div>';\n                    echo '</form>';\n                    echo '</div>';\n                }\n                // Print information on the grading method.\n                if ($strattempthighlight = quiz_report_highlighting_grading_method(\n                        $quiz, $this->qmsubselect, $options->onlygraded)) {\n                    echo '<div class=\"quizattemptcounts\">' . $strattempthighlight . '</div>';\n                }\n            }\n\n            // Define table columns.\n            $columns = array();\n            $headers = array();\n\n            if (!$table->is_downloading() && $options->checkboxcolumn) {\n                $columns[] = 'checkbox';\n                $headers[] = null;\n            }\n\n            $this->add_user_columns($table, $columns, $headers);\n            $this->add_state_column($columns, $headers);\n            $this->add_time_columns($columns, $headers);\n\n            $this->add_grade_columns($quiz, $options->usercanseegrades, $columns, $headers, false);\n\n            if (!$table->is_downloading() && has_capability('mod/quiz:regrade', $this->context) &&\n                    $this->has_regraded_questions($from, $where, $params)) {\n                $columns[] = 'regraded';\n                $headers[] = get_string('regrade', 'quiz_overview');\n            }\n\n            if ($options->slotmarks) {\n                foreach ($questions as $slot => $question) {\n                    // Ignore questions of zero length.\n                    $columns[] = 'qsgrade' . $slot;\n                    $header = get_string('qbrief', 'quiz', $question->number);\n                    if (!$table->is_downloading()) {\n                        $header .= '<br />';\n                    } else {\n                        $header .= ' ';\n                    }\n                    $header .= '/' . quiz_rescale_grade($question->maxmark, $quiz, 'question');\n                    $headers[] = $header;\n                }\n            }\n\n            $this->set_up_table_columns($table, $columns, $headers, $this->get_base_url(), $options, false);\n            $table->set_attribute('class', 'generaltable generalbox grades');\n\n            $table->out($options->pagesize, true);\n        }\n\n        if (!$table->is_downloading() && $options->usercanseegrades) {\n            $output = $PAGE->get_renderer('mod_quiz');\n            if ($currentgroup && $groupstudents) {\n                list($usql, $params) = $DB->get_in_or_equal($groupstudents);\n                $params[] = $quiz->id;\n                if ($DB->record_exists_select('quiz_grades', \"userid $usql AND quiz = ?\",\n                        $params)) {\n                    $imageurl = new moodle_url('/mod/quiz/report/overview/overviewgraph.php',\n                            array('id' => $quiz->id, 'groupid' => $currentgroup));\n                    $graphname = get_string('overviewreportgraphgroup', 'quiz_overview',\n                            groups_get_group_name($currentgroup));\n                    echo $output->graph($imageurl, $graphname);\n                }\n            }\n\n            if ($DB->record_exists('quiz_grades', array('quiz'=> $quiz->id))) {\n                $imageurl = new moodle_url('/mod/quiz/report/overview/overviewgraph.php',\n                        array('id' => $quiz->id));\n                $graphname = get_string('overviewreportgraph', 'quiz_overview');\n                echo $output->graph($imageurl, $graphname);\n            }\n        }\n        return true;\n    }\n\n    protected function process_actions($quiz, $cm, $currentgroup, $groupstudents, $allowed, $redirecturl) {\n        parent::process_actions($quiz, $cm, $currentgroup, $groupstudents, $allowed, $redirecturl);\n\n        if (empty($currentgroup) || $groupstudents) {\n            if (optional_param('regrade', 0, PARAM_BOOL) && confirm_sesskey()) {\n                if ($attemptids = optional_param_array('attemptid', array(), PARAM_INT)) {\n                    require_capability('mod/quiz:regrade', $this->context);\n                    $this->regrade_attempts($quiz, false, $groupstudents, $attemptids);\n                    redirect($redirecturl, '', 5);\n                }\n            }\n        }\n\n        if (optional_param('regradeall', 0, PARAM_BOOL) && confirm_sesskey()) {\n            require_capability('mod/quiz:regrade', $this->context);\n            $this->regrade_attempts($quiz, false, $groupstudents);\n            redirect($redirecturl, '', 5);\n\n        } else if (optional_param('regradealldry', 0, PARAM_BOOL) && confirm_sesskey()) {\n            require_capability('mod/quiz:regrade', $this->context);\n            $this->regrade_attempts($quiz, true, $groupstudents);\n            redirect($redirecturl, '', 5);\n\n        } else if (optional_param('regradealldrydo', 0, PARAM_BOOL) && confirm_sesskey()) {\n            require_capability('mod/quiz:regrade', $this->context);\n            $this->regrade_attempts_needing_it($quiz, $groupstudents);\n            redirect($redirecturl, '', 5);\n        }\n    }\n\n    /**\n     * Regrade a particular quiz attempt. Either for real ($dryrun = false), or\n     * as a pretend regrade to see which fractions would change. The outcome is\n     * stored in the quiz_overview_regrades table.\n     *\n     * Note, $attempt is not upgraded in the database. The caller needs to do that.\n     * However, $attempt->sumgrades is updated, if this is not a dry run.\n     *\n     * @param object $attempt the quiz attempt to regrade.\n     * @param bool $dryrun if true, do a pretend regrade, otherwise do it for real.\n     * @param array $slots if null, regrade all questions, otherwise, just regrade\n     *      the quetsions with those slots.\n     */\n    protected function regrade_attempt($attempt, $dryrun = false, $slots = null) {\n        global $DB;\n        set_time_limit(30);\n\n        $transaction = $DB->start_delegated_transaction();\n\n        $quba = question_engine::load_questions_usage_by_activity($attempt->uniqueid);\n\n        if (is_null($slots)) {\n            $slots = $quba->get_slots();\n        }\n\n        $finished = $attempt->state == quiz_attempt::FINISHED;\n        foreach ($slots as $slot) {\n            $qqr = new stdClass();\n            $qqr->oldfraction = $quba->get_question_fraction($slot);\n\n            $quba->regrade_question($slot, $finished);\n\n            $qqr->newfraction = $quba->get_question_fraction($slot);\n\n            if (abs($qqr->oldfraction - $qqr->newfraction) > 1e-7) {\n                $qqr->questionusageid = $quba->get_id();\n                $qqr->slot = $slot;\n                $qqr->regraded = empty($dryrun);\n                $qqr->timemodified = time();\n                $DB->insert_record('quiz_overview_regrades', $qqr, false);\n            }\n        }\n\n        if (!$dryrun) {\n            question_engine::save_questions_usage_by_activity($quba);\n        }\n\n        $transaction->allow_commit();\n\n        // Really, PHP should not need this hint, but without this, we just run out of memory.\n        $quba = null;\n        $transaction = null;\n        gc_collect_cycles();\n    }\n\n    /**\n     * Regrade attempts for this quiz, exactly which attempts are regraded is\n     * controlled by the parameters.\n     * @param object $quiz the quiz settings.\n     * @param bool $dryrun if true, do a pretend regrade, otherwise do it for real.\n     * @param array $groupstudents blank for all attempts, otherwise regrade attempts\n     * for these users.\n     * @param array $attemptids blank for all attempts, otherwise only regrade\n     * attempts whose id is in this list.\n     */\n    protected function regrade_attempts($quiz, $dryrun = false,\n            $groupstudents = array(), $attemptids = array()) {\n        global $DB;\n\n        $where = \"quiz = ? AND preview = 0\";\n        $params = array($quiz->id);\n\n        if ($groupstudents) {\n            list($usql, $uparams) = $DB->get_in_or_equal($groupstudents);\n            $where .= \" AND userid $usql\";\n            $params = array_merge($params, $uparams);\n        }\n\n        if ($attemptids) {\n            list($asql, $aparams) = $DB->get_in_or_equal($attemptids);\n            $where .= \" AND id $asql\";\n            $params = array_merge($params, $aparams);\n        }\n\n        $attempts = $DB->get_records_select('quiz_attempts', $where, $params);\n        if (!$attempts) {\n            return;\n        }\n\n        $this->clear_regrade_table($quiz, $groupstudents);\n\n        foreach ($attempts as $attempt) {\n            $this->regrade_attempt($attempt, $dryrun);\n        }\n\n        if (!$dryrun) {\n            $this->update_overall_grades($quiz);\n        }\n    }\n\n    /**\n     * Regrade those questions in those attempts that are marked as needing regrading\n     * in the quiz_overview_regrades table.\n     * @param object $quiz the quiz settings.\n     * @param array $groupstudents blank for all attempts, otherwise regrade attempts\n     * for these users.\n     */\n    protected function regrade_attempts_needing_it($quiz, $groupstudents) {\n        global $DB;\n\n        $where = \"quiza.quiz = ? AND quiza.preview = 0 AND qqr.regraded = 0\";\n        $params = array($quiz->id);\n\n        // Fetch all attempts that need regrading.\n        if ($groupstudents) {\n            list($usql, $uparams) = $DB->get_in_or_equal($groupstudents);\n            $where .= \" AND quiza.userid $usql\";\n            $params += $uparams;\n        }\n\n        $toregrade = $DB->get_records_sql(\"\n                SELECT quiza.uniqueid, qqr.slot\n                FROM {quiz_attempts} quiza\n                JOIN {quiz_overview_regrades} qqr ON qqr.questionusageid = quiza.uniqueid\n                WHERE $where\", $params);\n\n        if (!$toregrade) {\n            return;\n        }\n\n        $attemptquestions = array();\n        foreach ($toregrade as $row) {\n            $attemptquestions[$row->uniqueid][] = $row->slot;\n        }\n        $attempts = $DB->get_records_list('quiz_attempts', 'uniqueid',\n                array_keys($attemptquestions));\n\n        $this->clear_regrade_table($quiz, $groupstudents);\n\n        foreach ($attempts as $attempt) {\n            $this->regrade_attempt($attempt, false, $attemptquestions[$attempt->uniqueid]);\n        }\n\n        $this->update_overall_grades($quiz);\n    }\n\n    /**\n     * Count the number of attempts in need of a regrade.\n     * @param object $quiz the quiz settings.\n     * @param array $groupstudents user ids. If this is given, only data relating\n     * to these users is cleared.\n     */\n    protected function count_question_attempts_needing_regrade($quiz, $groupstudents) {\n        global $DB;\n\n        $usertest = '';\n        $params = array();\n        if ($groupstudents) {\n            list($usql, $params) = $DB->get_in_or_equal($groupstudents);\n            $usertest = \"quiza.userid $usql AND \";\n        }\n\n        $params[] = $quiz->id;\n        $sql = \"SELECT COUNT(DISTINCT quiza.id)\n                FROM {quiz_attempts} quiza\n                JOIN {quiz_overview_regrades} qqr ON quiza.uniqueid = qqr.questionusageid\n                WHERE\n                    $usertest\n                    quiza.quiz = ? AND\n                    quiza.preview = 0 AND\n                    qqr.regraded = 0\";\n        return $DB->count_records_sql($sql, $params);\n    }\n\n    /**\n     * Are there any pending regrades in the table we are going to show?\n     * @param string $from tables used by the main query.\n     * @param string $where where clause used by the main query.\n     * @param array $params required by the SQL.\n     * @return bool whether there are pending regrades.\n     */\n    protected function has_regraded_questions($from, $where, $params) {\n        global $DB;\n        $qubaids = new qubaid_join($from, 'uniqueid', $where, $params);\n        return $DB->record_exists_select('quiz_overview_regrades',\n                'questionusageid ' . $qubaids->usage_id_in(),\n                $qubaids->usage_id_in_params());\n    }\n\n    /**\n     * Remove all information about pending/complete regrades from the database.\n     * @param object $quiz the quiz settings.\n     * @param array $groupstudents user ids. If this is given, only data relating\n     * to these users is cleared.\n     */\n    protected function clear_regrade_table($quiz, $groupstudents) {\n        global $DB;\n\n        // Fetch all attempts that need regrading.\n        $where = '';\n        $params = array();\n        if ($groupstudents) {\n            list($usql, $params) = $DB->get_in_or_equal($groupstudents);\n            $where = \"userid $usql AND \";\n        }\n\n        $params[] = $quiz->id;\n        $DB->delete_records_select('quiz_overview_regrades',\n                \"questionusageid IN (\n                    SELECT uniqueid\n                    FROM {quiz_attempts}\n                    WHERE $where quiz = ?\n                )\", $params);\n    }\n\n    /**\n     * Update the final grades for all attempts. This method is used following\n     * a regrade.\n     * @param object $quiz the quiz settings.\n     * @param array $userids only update scores for these userids.\n     * @param array $attemptids attemptids only update scores for these attempt ids.\n     */\n    protected function update_overall_grades($quiz) {\n        quiz_update_all_attempt_sumgrades($quiz);\n        quiz_update_all_final_grades($quiz);\n        quiz_update_grades($quiz);\n    }\n}\n
===================================================================
--- mod/quiz/report/overview/report.php	(revision bbcf8dab4f0f4db1b766733a479a86fc07484831)
+++ mod/quiz/report/overview/report.php	(revision )
@@ -28,7 +28,8 @@
 require_once($CFG->dirroot . '/mod/quiz/report/attemptsreport.php');
 require_once($CFG->dirroot . '/mod/quiz/report/overview/overview_options.php');
 require_once($CFG->dirroot . '/mod/quiz/report/overview/overview_form.php');
-require_once($CFG->dirroot . '/mod/quiz/report/overview/overview_table.php');
+//Grade By Category Change to Core : Following line has been changed. Required filename changed.
+require_once($CFG->dirroot . '/mod/quiz/accessrule/gradebycategory/overview_table_with_category_totals.php');
 
 
 /**
@@ -68,7 +68,8 @@ class quiz_overview_report extends quiz_attempts_report {
         // Prepare for downloading, if applicable.
         $courseshortname = format_string($course->shortname, true,
                 array('context' => context_course::instance($course->id)));
-        $table = new quiz_overview_table($quiz, $this->context, $this->qmsubselect,
+        //Grade By Category Change to Core : Following line has been changed. Class name changed.
+        $table = new quiz_overview_table_with_category_totals($quiz, $this->context, $this->qmsubselect,
                 $options, $groupstudents, $students, $questions, $options->get_url());
         $filename = quiz_report_download_filename(get_string('overviewfilename', 'quiz_overview'),
                 $courseshortname, $quiz->name);
Index: mod/quiz/settings.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Administration settings definitions for the quiz module.\n *\n * @package    mod\n * @subpackage quiz\n * @copyright  2010 Petr Skoda\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG->dirroot . '/mod/quiz/lib.php');\nrequire_once($CFG->dirroot . '/mod/quiz/settingslib.php');\n\n// First get a list of quiz reports with there own settings pages. If there none,\n// we use a simpler overall menu structure.\n$reports = get_plugin_list_with_file('quiz', 'settings.php', false);\n$reportsbyname = array();\nforeach ($reports as $report => $reportdir) {\n    $strreportname = get_string($report . 'report', 'quiz_'.$report);\n    $reportsbyname[$strreportname] = $report;\n}\nksort($reportsbyname);\n\n// Create the quiz settings page.\nif (empty($reportsbyname)) {\n    $pagetitle = get_string('modulename', 'quiz');\n} else {\n    $pagetitle = get_string('generalsettings', 'admin');\n}\n$quizsettings = new admin_settingpage('modsettingquiz', $pagetitle, 'moodle/site:config');\n\n// Introductory explanation that all the settings are defaults for the add quiz form.\n$quizsettings->add(new admin_setting_heading('quizintro', '', get_string('configintro', 'quiz')));\n\n// Time limit.\n$quizsettings->add(new admin_setting_configtext_with_advanced('quiz/timelimit',\n        get_string('timelimitsec', 'quiz'), get_string('configtimelimitsec', 'quiz'),\n        array('value' => '0', 'adv' => false), PARAM_INT));\n\n// What to do with overdue attempts.\n$quizsettings->add(new mod_quiz_admin_setting_overduehandling('quiz/overduehandling',\n        get_string('overduehandling', 'quiz'), get_string('overduehandling_desc', 'quiz'),\n        array('value' => 'autoabandon', 'adv' => false), null));\n\n// Grace period time.\n$quizsettings->add(new admin_setting_configtext_with_advanced('quiz/graceperiod',\n        get_string('graceperiod', 'quiz'), get_string('graceperiod_desc', 'quiz'),\n        array('value' => '86400', 'adv' => false), PARAM_INT));\n\n// Minimum grace period used behind the scenes.\n$quizsettings->add(new admin_setting_configtext('quiz/graceperiodmin',\n        get_string('graceperiodmin', 'quiz'), get_string('graceperiodmin_desc', 'quiz'),\n        60, PARAM_INT));\n\n// Number of attempts.\n$options = array(get_string('unlimited'));\nfor ($i = 1; $i <= QUIZ_MAX_ATTEMPT_OPTION; $i++) {\n    $options[$i] = $i;\n}\n$quizsettings->add(new admin_setting_configselect_with_advanced('quiz/attempts',\n        get_string('attemptsallowed', 'quiz'), get_string('configattemptsallowed', 'quiz'),\n        array('value' => 0, 'adv' => false), $options));\n\n// Grading method.\n$quizsettings->add(new mod_quiz_admin_setting_grademethod('quiz/grademethod',\n        get_string('grademethod', 'quiz'), get_string('configgrademethod', 'quiz'),\n        array('value' => QUIZ_GRADEHIGHEST, 'adv' => false), null));\n\n// Maximum grade.\n$quizsettings->add(new admin_setting_configtext('quiz/maximumgrade',\n        get_string('maximumgrade'), get_string('configmaximumgrade', 'quiz'), 10, PARAM_INT));\n\n// Shuffle questions.\n$quizsettings->add(new admin_setting_configcheckbox_with_advanced('quiz/shufflequestions',\n        get_string('shufflequestions', 'quiz'), get_string('configshufflequestions', 'quiz'),\n        array('value' => 0, 'adv' => false)));\n\n// Questions per page.\n$perpage = array();\n$perpage[0] = get_string('never');\n$perpage[1] = get_string('aftereachquestion', 'quiz');\nfor ($i = 2; $i <= QUIZ_MAX_QPP_OPTION; ++$i) {\n    $perpage[$i] = get_string('afternquestions', 'quiz', $i);\n}\n$quizsettings->add(new admin_setting_configselect_with_advanced('quiz/questionsperpage',\n        get_string('newpageevery', 'quiz'), get_string('confignewpageevery', 'quiz'),\n        array('value' => 1, 'adv' => false), $perpage));\n\n// Navigation method.\n$quizsettings->add(new admin_setting_configselect_with_advanced('quiz/navmethod',\n        get_string('navmethod', 'quiz'), get_string('confignavmethod', 'quiz'),\n        array('value' => QUIZ_NAVMETHOD_FREE, 'adv' => true), quiz_get_navigation_options()));\n\n// Shuffle within questions.\n$quizsettings->add(new admin_setting_configcheckbox_with_advanced('quiz/shuffleanswers',\n        get_string('shufflewithin', 'quiz'), get_string('configshufflewithin', 'quiz'),\n        array('value' => 1, 'adv' => false)));\n\n// Preferred behaviour.\n$quizsettings->add(new admin_setting_question_behaviour('quiz/preferredbehaviour',\n        get_string('howquestionsbehave', 'question'), get_string('howquestionsbehave_desc', 'quiz'),\n        'deferredfeedback'));\n\n// Each attempt builds on last.\n$quizsettings->add(new admin_setting_configcheckbox_with_advanced('quiz/attemptonlast',\n        get_string('eachattemptbuildsonthelast', 'quiz'),\n        get_string('configeachattemptbuildsonthelast', 'quiz'),\n        array('value' => 0, 'adv' => true)));\n\n// Review options.\n$quizsettings->add(new admin_setting_heading('reviewheading',\n        get_string('reviewoptionsheading', 'quiz'), ''));\nforeach (mod_quiz_admin_review_setting::fields() as $field => $name) {\n    $default = mod_quiz_admin_review_setting::all_on();\n    $forceduring = null;\n    if ($field == 'attempt') {\n        $forceduring = true;\n    } else if ($field == 'overallfeedback') {\n        $default = $default ^ mod_quiz_admin_review_setting::DURING;\n        $forceduring = false;\n    }\n    $quizsettings->add(new mod_quiz_admin_review_setting('quiz/review' . $field,\n            $name, '', $default, $forceduring));\n}\n\n// Show the user's picture.\n$quizsettings->add(new admin_setting_configcheckbox_with_advanced('quiz/showuserpicture',\n        get_string('showuserpicture', 'quiz'), get_string('configshowuserpicture', 'quiz'),\n        array('value' => 0, 'adv' => false)));\n\n// Decimal places for overall grades.\n$options = array();\nfor ($i = 0; $i <= QUIZ_MAX_DECIMAL_OPTION; $i++) {\n    $options[$i] = $i;\n}\n$quizsettings->add(new admin_setting_configselect_with_advanced('quiz/decimalpoints',\n        get_string('decimalplaces', 'quiz'), get_string('configdecimalplaces', 'quiz'),\n        array('value' => 2, 'adv' => false), $options));\n\n// Decimal places for question grades.\n$options = array(-1 => get_string('sameasoverall', 'quiz'));\nfor ($i = 0; $i <= QUIZ_MAX_Q_DECIMAL_OPTION; $i++) {\n    $options[$i] = $i;\n}\n$quizsettings->add(new admin_setting_configselect_with_advanced('quiz/questiondecimalpoints',\n        get_string('decimalplacesquestion', 'quiz'),\n        get_string('configdecimalplacesquestion', 'quiz'),\n        array('value' => -1, 'adv' => true), $options));\n\n// Show blocks during quiz attempts.\n$quizsettings->add(new admin_setting_configcheckbox_with_advanced('quiz/showblocks',\n        get_string('showblocks', 'quiz'), get_string('configshowblocks', 'quiz'),\n        array('value' => 0, 'adv' => true)));\n\n// Password.\n$quizsettings->add(new admin_setting_configtext_with_advanced('quiz/password',\n        get_string('requirepassword', 'quiz'), get_string('configrequirepassword', 'quiz'),\n        array('value' => '', 'adv' => true), PARAM_TEXT));\n\n// IP restrictions.\n$quizsettings->add(new admin_setting_configtext_with_advanced('quiz/subnet',\n        get_string('requiresubnet', 'quiz'), get_string('configrequiresubnet', 'quiz'),\n        array('value' => '', 'adv' => true), PARAM_TEXT));\n\n// Enforced delay between attempts.\n$quizsettings->add(new admin_setting_configtext_with_advanced('quiz/delay1',\n        get_string('delay1st2nd', 'quiz'), get_string('configdelay1st2nd', 'quiz'),\n        array('value' => 0, 'adv' => true), PARAM_INT));\n$quizsettings->add(new admin_setting_configtext_with_advanced('quiz/delay2',\n        get_string('delaylater', 'quiz'), get_string('configdelaylater', 'quiz'),\n        array('value' => 0, 'adv' => true), PARAM_INT));\n\n// Browser security.\n$quizsettings->add(new mod_quiz_admin_setting_browsersecurity('quiz/browsersecurity',\n        get_string('showinsecurepopup', 'quiz'), get_string('configpopup', 'quiz'),\n        array('value' => '-', 'adv' => true), null));\n\n// Allow user to specify if setting outcomes is an advanced setting\nif (!empty($CFG->enableoutcomes)) {\n    $quizsettings->add(new admin_setting_configcheckbox('quiz/outcomes_adv',\n        get_string('outcomesadvanced', 'quiz'), get_string('configoutcomesadvanced', 'quiz'),\n        '0'));\n}\n\n// Now, depending on whether any reports have their own settings page, add\n// the quiz setting page to the appropriate place in the tree.\nif (empty($reportsbyname)) {\n    $ADMIN->add('modsettings', $quizsettings);\n} else {\n    $ADMIN->add('modsettings', new admin_category('modsettingsquizcat',\n            get_string('modulename', 'quiz'), !$module->visible));\n    $ADMIN->add('modsettingsquizcat', $quizsettings);\n\n    // Add the report pages for the settings.php files in sub directories of mod/quiz/report.\n    foreach ($reportsbyname as $strreportname => $report) {\n        $reportname = $report;\n\n        $settings = new admin_settingpage('modsettingsquizcat'.$reportname,\n                $strreportname, 'moodle/site:config', !$module->visible);\n        if ($ADMIN->fulltree) {\n            include($CFG->dirroot . \"/mod/quiz/report/$reportname/settings.php\");\n        }\n        $ADMIN->add('modsettingsquizcat', $settings);\n    }\n}\n\n$settings = null; // We do not want standard settings link.\n
===================================================================
--- mod/quiz/settings.php	(revision bbcf8dab4f0f4db1b766733a479a86fc07484831)
+++ mod/quiz/settings.php	(revision )
@@ -252,3 +252,6 @@ if (empty($reportsbyname) && empty($rulesbyname)) {
 }
 
 $settings = null; // We do not want standard settings link.
+
+//Grade By Category Change to Core : Following line has been added.
+require($CFG->dirroot.'/mod/quiz/accessrule/gradebycategory/settings.php');
